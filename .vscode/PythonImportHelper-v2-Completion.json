[
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Statement",
        "importPath": "models.Statement",
        "description": "models.Statement",
        "isExtraImport": true,
        "detail": "models.Statement",
        "documentation": {}
    },
    {
        "label": "Statement",
        "importPath": "models.Statement",
        "description": "models.Statement",
        "isExtraImport": true,
        "detail": "models.Statement",
        "documentation": {}
    },
    {
        "label": "Statement",
        "importPath": "models.Statement",
        "description": "models.Statement",
        "isExtraImport": true,
        "detail": "models.Statement",
        "documentation": {}
    },
    {
        "label": "Statement",
        "importPath": "models.Statement",
        "description": "models.Statement",
        "isExtraImport": true,
        "detail": "models.Statement",
        "documentation": {}
    },
    {
        "label": "Statement",
        "importPath": "models.Statement",
        "description": "models.Statement",
        "isExtraImport": true,
        "detail": "models.Statement",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "StatementType",
        "importPath": "models.StatementType",
        "description": "models.StatementType",
        "isExtraImport": true,
        "detail": "models.StatementType",
        "documentation": {}
    },
    {
        "label": "StatementType",
        "importPath": "models.StatementType",
        "description": "models.StatementType",
        "isExtraImport": true,
        "detail": "models.StatementType",
        "documentation": {}
    },
    {
        "label": "StatementType",
        "importPath": "models.StatementType",
        "description": "models.StatementType",
        "isExtraImport": true,
        "detail": "models.StatementType",
        "documentation": {}
    },
    {
        "label": "StatementType",
        "importPath": "models.StatementType",
        "description": "models.StatementType",
        "isExtraImport": true,
        "detail": "models.StatementType",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Flow",
        "importPath": "models.Flow",
        "description": "models.Flow",
        "isExtraImport": true,
        "detail": "models.Flow",
        "documentation": {}
    },
    {
        "label": "Flow",
        "importPath": "models.Flow",
        "description": "models.Flow",
        "isExtraImport": true,
        "detail": "models.Flow",
        "documentation": {}
    },
    {
        "label": "ConditionClause",
        "importPath": "models.ConditionClause",
        "description": "models.ConditionClause",
        "isExtraImport": true,
        "detail": "models.ConditionClause",
        "documentation": {}
    },
    {
        "label": "ConditionClause",
        "importPath": "models.ConditionClause",
        "description": "models.ConditionClause",
        "isExtraImport": true,
        "detail": "models.ConditionClause",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "FileStream",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "CommonTokenStream",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "FileStream",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "CommonTokenStream",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "logger",
        "description": "logger",
        "isExtraImport": true,
        "detail": "logger",
        "documentation": {}
    },
    {
        "label": "Cobol85Lexer",
        "importPath": "grammars.Cobol85Lexer",
        "description": "grammars.Cobol85Lexer",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Lexer",
        "documentation": {}
    },
    {
        "label": "Cobol85Lexer",
        "importPath": "grammars.Cobol85Lexer",
        "description": "grammars.Cobol85Lexer",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Lexer",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Parser",
        "importPath": "grammars.Cobol85Parser",
        "description": "grammars.Cobol85Parser",
        "isExtraImport": true,
        "detail": "grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "parse_procedure_division_section",
        "importPath": "parse_procedure_division",
        "description": "parse_procedure_division",
        "isExtraImport": true,
        "detail": "parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "parse_procedure_division",
        "importPath": "parse_procedure_division",
        "description": "parse_procedure_division",
        "isExtraImport": true,
        "detail": "parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "parse_identification_division_section",
        "importPath": "parse_identification_division",
        "description": "parse_identification_division",
        "isExtraImport": true,
        "detail": "parse_identification_division",
        "documentation": {}
    },
    {
        "label": "parse_identification_division",
        "importPath": "parse_identification_division",
        "description": "parse_identification_division",
        "isExtraImport": true,
        "detail": "parse_identification_division",
        "documentation": {}
    },
    {
        "label": "parse_working_storage_section",
        "importPath": "parse_working_storage",
        "description": "parse_working_storage",
        "isExtraImport": true,
        "detail": "parse_working_storage",
        "documentation": {}
    },
    {
        "label": "parse_linkage_section",
        "importPath": "parse_linkage",
        "description": "parse_linkage",
        "isExtraImport": true,
        "detail": "parse_linkage",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ErrorListener",
        "importPath": "antlr4.error.ErrorListener",
        "description": "antlr4.error.ErrorListener",
        "isExtraImport": true,
        "detail": "antlr4.error.ErrorListener",
        "documentation": {}
    },
    {
        "label": "parse_working_storage",
        "importPath": "parse_working_storage_section",
        "description": "parse_working_storage_section",
        "isExtraImport": true,
        "detail": "parse_working_storage_section",
        "documentation": {}
    },
    {
        "label": "parse_linkage_section",
        "importPath": "parse_linkage_section",
        "description": "parse_linkage_section",
        "isExtraImport": true,
        "detail": "parse_linkage_section",
        "documentation": {}
    },
    {
        "label": "StaticAnalysis",
        "importPath": "models.StaticAnalysis",
        "description": "models.StaticAnalysis",
        "isExtraImport": true,
        "detail": "models.StaticAnalysis",
        "documentation": {}
    },
    {
        "label": "StaticAnalysis",
        "importPath": "models.StaticAnalysis",
        "description": "models.StaticAnalysis",
        "isExtraImport": true,
        "detail": "models.StaticAnalysis",
        "documentation": {}
    },
    {
        "label": "StaticAnalysis",
        "importPath": "models.StaticAnalysis",
        "description": "models.StaticAnalysis",
        "isExtraImport": true,
        "detail": "models.StaticAnalysis",
        "documentation": {}
    },
    {
        "label": "context_info",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "context_info",
        "description": "context_info",
        "detail": "context_info",
        "documentation": {}
    },
    {
        "label": "parse_statements",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "parse_statements",
        "description": "parse_statements",
        "detail": "parse_statements",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "importPath": "models.AssignStatement",
        "description": "models.AssignStatement",
        "isExtraImport": true,
        "detail": "models.AssignStatement",
        "documentation": {}
    },
    {
        "label": "ConditionalStatement",
        "importPath": "models.ConditionalStatement",
        "description": "models.ConditionalStatement",
        "isExtraImport": true,
        "detail": "models.ConditionalStatement",
        "documentation": {}
    },
    {
        "label": "CallStatement",
        "importPath": "models.CallStatement",
        "description": "models.CallStatement",
        "isExtraImport": true,
        "detail": "models.CallStatement",
        "documentation": {}
    },
    {
        "label": "CallCicsStatement",
        "importPath": "models.CallStatement",
        "description": "models.CallStatement",
        "isExtraImport": true,
        "detail": "models.CallStatement",
        "documentation": {}
    },
    {
        "label": "GraphDatabase",
        "importPath": "neo4j",
        "description": "neo4j",
        "isExtraImport": true,
        "detail": "neo4j",
        "documentation": {}
    },
    {
        "label": "GraphDatabase",
        "importPath": "neo4j",
        "description": "neo4j",
        "isExtraImport": true,
        "detail": "neo4j",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "neo4j",
        "description": "neo4j",
        "isExtraImport": true,
        "detail": "neo4j",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "static_analysis",
        "description": "static_analysis",
        "isExtraImport": true,
        "detail": "static_analysis",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "static_analysis",
        "description": "static_analysis",
        "isExtraImport": true,
        "detail": "static_analysis",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "static_analysis",
        "description": "static_analysis",
        "isExtraImport": true,
        "detail": "static_analysis",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "static_analysis",
        "description": "static_analysis",
        "isExtraImport": true,
        "detail": "static_analysis",
        "documentation": {}
    },
    {
        "label": "db_connection",
        "importPath": "static_analysis.process_results",
        "description": "static_analysis.process_results",
        "isExtraImport": true,
        "detail": "static_analysis.process_results",
        "documentation": {}
    },
    {
        "label": "db_context",
        "importPath": "static_analysis.process_results",
        "description": "static_analysis.process_results",
        "isExtraImport": true,
        "detail": "static_analysis.process_results",
        "documentation": {}
    },
    {
        "label": "db_connection",
        "importPath": "static_analysis.process_results",
        "description": "static_analysis.process_results",
        "isExtraImport": true,
        "detail": "static_analysis.process_results",
        "documentation": {}
    },
    {
        "label": "db_context",
        "importPath": "static_analysis.process_results",
        "description": "static_analysis.process_results",
        "isExtraImport": true,
        "detail": "static_analysis.process_results",
        "documentation": {}
    },
    {
        "label": "db_connection",
        "importPath": "static_analysis.process_results",
        "description": "static_analysis.process_results",
        "isExtraImport": true,
        "detail": "static_analysis.process_results",
        "documentation": {}
    },
    {
        "label": "ConditionClause",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.ConditionClause",
        "description": "src.static_analysis.cobol_parser.models.ConditionClause",
        "peekOfCode": "class ConditionClause:\n    \"\"\"Represents a single condition clause inside a ConditionalStatement.\"\"\"\n    Left: str = \"\"\n    Operator: str = \"\"\n    Right: str = \"\"\n    @property\n    def Clause(self) -> str:\n        \"\"\"Dynamically generates the clause as 'Left Operator Right'.\"\"\"\n        return f\"{self.Left} {self.Operator} {self.Right}\".strip()\n    @property",
        "detail": "src.static_analysis.cobol_parser.models.ConditionClause",
        "documentation": {}
    },
    {
        "label": "Flow",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.Flow",
        "description": "src.static_analysis.cobol_parser.models.Flow",
        "peekOfCode": "class Flow:\n    \"\"\"\n    Represents a COBOL PROCEDURE DIVISION flow.\n    Contains a list of executed statements.\n    \"\"\"\n    Name: str = \"\"\n    Input: Dict = field(default_factory=dict)\n    Output: Dict = field(default_factory=dict)\n    Statements: List[\"Statement\"] = field(default_factory=list)\n    def addSentence(self, statement: \"Statement\"):",
        "detail": "src.static_analysis.cobol_parser.models.Flow",
        "documentation": {}
    },
    {
        "label": "Statement",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.Statement",
        "description": "src.static_analysis.cobol_parser.models.Statement",
        "peekOfCode": "class Statement:\n    \"\"\"Base class for all COBOL statements.\"\"\"\n    id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    type: StatementType = StatementType.OTHER\n    methodName: str = \"\"\n    def to_json(self):\n        return {\n            \"id\": self.id,\n            \"type\": self.type.name \n        }",
        "detail": "src.static_analysis.cobol_parser.models.Statement",
        "documentation": {}
    },
    {
        "label": "StatementType",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.StatementType",
        "description": "src.static_analysis.cobol_parser.models.StatementType",
        "peekOfCode": "class StatementType(Enum):\n    ASSIGN = \"ASSIGN\"\n    CALL = \"CALL\"\n    CONDITION = \"CONDITION\"\n    CICS = \"CICS\"\n    OTHER = \"OTHER\"",
        "detail": "src.static_analysis.cobol_parser.models.StatementType",
        "documentation": {}
    },
    {
        "label": "StaticAnalysis",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.StaticAnalysis",
        "description": "src.static_analysis.cobol_parser.models.StaticAnalysis",
        "peekOfCode": "class StaticAnalysis:\n    ProgramId: str = \"\"\n    Author: str = \"\"\n    Installation: str = \"\"\n    DateWritten: str = None\n    Compiled: str = None\n    Security: str = None\n    Flow: List[\"Flow\"] = field(default_factory=list) \n    DataStructures: List[dict] = field(default_factory=list)\n    def addFlow(self, flow: \"Flow\"):",
        "detail": "src.static_analysis.cobol_parser.models.StaticAnalysis",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.AssignStatement",
        "description": "src.static_analysis.cobol_parser.models.AssignStatement",
        "peekOfCode": "class AssignStatement(Statement):\n    \"\"\"Represents a COBOL MOVE statement.\"\"\"\n    AssignFrom: str = \"\"\n    AssignTo: str = \"\"\n    def __post_init__(self):\n        self.type = StatementType.ASSIGN\n    @property\n    def raw(self) -> str:\n        \"\"\"Returns the assignment operation in string format.\"\"\"\n        return f\"{self.AssignFrom} = {self.AssignTo}\"",
        "detail": "src.static_analysis.cobol_parser.models.AssignStatement",
        "documentation": {}
    },
    {
        "label": "ConditionalStatement",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.ConditionalStatement",
        "description": "src.static_analysis.cobol_parser.models.ConditionalStatement",
        "peekOfCode": "class ConditionalStatement(Statement):\n    \"\"\"Represents a conditional statement (IF condition) in COBOL code.\"\"\"\n    conditionClauses: List[\"ConditionClause\"] = field(default_factory=list)\n    TrueStatements: List[\"Statement\"] = field(default_factory=list)\n    FalseStatements: List[\"Statement\"] = field(default_factory=list)\n    def __post_init__(self):\n        self.type = StatementType.CONDITION\n    def addClause(self, clause):\n        \"\"\"Adds a condition clause to the statement.\"\"\"\n        if isinstance(clause, ConditionClause):",
        "detail": "src.static_analysis.cobol_parser.models.ConditionalStatement",
        "documentation": {}
    },
    {
        "label": "CallStatement",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.CallStatement",
        "description": "src.static_analysis.cobol_parser.models.CallStatement",
        "peekOfCode": "class CallStatement(Statement):\n    \"\"\"Represents a COBOL PERFORM, CALL, or EXEC CICS statement.\"\"\"\n    Statements: List[\"Statement\"] = field(default_factory=list)  # Υποστηρίζει sub-statements για CICS\n    def __post_init__(self, is_internal = True):\n        self.type = StatementType.CALL\n        self.Internal = is_internal\n    @property\n    def raw(self) -> str:\n        \"\"\"Returns the raw execution string.\"\"\"\n        call_type = \"Perform\" if self.Internal else \"Call\"",
        "detail": "src.static_analysis.cobol_parser.models.CallStatement",
        "documentation": {}
    },
    {
        "label": "CallCicsStatement",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.models.CallStatement",
        "description": "src.static_analysis.cobol_parser.models.CallStatement",
        "peekOfCode": "class CallCicsStatement(Statement):\n    \"\"\"Represents a COBOL EXEC CICS statement.\"\"\"\n    Statements: List[\"Statement\"] = field(default_factory=list)  # Υποστηρίζει sub-statements για CICS\n    def __post_init__(self):\n        self.type = StatementType.CICS\n    @property\n    def raw(self) -> str:\n        \"\"\"Returns the full EXEC CICS command.\"\"\"\n        params = \" \".join(statement.raw for statement in self.Statements)\n        return f\"EXEC CICS {self.methodName} {params}\"",
        "detail": "src.static_analysis.cobol_parser.models.CallStatement",
        "documentation": {}
    },
    {
        "label": "Cobol85Lexer",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85Lexer",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85Lexer",
        "peekOfCode": "class Cobol85Lexer(Lexer):\n    atn = ATNDeserializer().deserialize(serializedATN())\n    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n    IDENTIFICATIONLINE = 1\n    AUTHORLINE = 2\n    INSTALLATIONLINE = 3\n    DATE_WRITTENLINE = 4\n    DATE_COMPILEDLINE = 5\n    SECURITYLINE = 6\n    REMARKSLINE = 7",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85Lexer",
        "documentation": {}
    },
    {
        "label": "serializedATN",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85Lexer",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85Lexer",
        "peekOfCode": "def serializedATN():\n    return [\n        4,0,580,6089,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,\n        5,2,6,7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,\n        2,13,7,13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,\n        7,19,2,20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,\n        2,26,7,26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,\n        7,32,2,33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,\n        2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,\n        7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85Lexer",
        "documentation": {}
    },
    {
        "label": "Cobol85Parse",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85Parser",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85Parser",
        "peekOfCode": "class Cobol85Parser ( Parser ):\n    grammarFileName = \"Cobol85.g4\"\n    atn = ATNDeserializer().deserialize(serializedATN())\n    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n    sharedContextCache = PredictionContextCache()\n    literalNames = [ \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"'MAP'\", \"'MAPSET'\", \"'XCTL'\", \"'FORMATTIME'\", \"'EXEC'\", \n                     \"'CICS'\", \"'END-EXEC'\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", ",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "serializedATN",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85Parser",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85Parser",
        "peekOfCode": "def serializedATN():\n    return [\n        4,1,580,6358,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,\n        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,\n        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,\n        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,\n        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,\n        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,\n        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,\n        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85Parser",
        "documentation": {}
    },
    {
        "label": "Cobol85Listener",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85Listener",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85Listener",
        "peekOfCode": "class Cobol85Listener(ParseTreeListener):\n    # Enter a parse tree produced by Cobol85Parser#startRule.\n    def enterStartRule(self, ctx:Cobol85Parser.StartRuleContext):\n        pass\n    # Exit a parse tree produced by Cobol85Parser#startRule.\n    def exitStartRule(self, ctx:Cobol85Parser.StartRuleContext):\n        pass\n    # Enter a parse tree produced by Cobol85Parser#compilationUnit.\n    def enterCompilationUnit(self, ctx:Cobol85Parser.CompilationUnitContext):\n        pass",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85Listener",
        "documentation": {}
    },
    {
        "label": "Cobol85Visitor",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85Visitor",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85Visitor",
        "peekOfCode": "class Cobol85Visitor(ParseTreeVisitor):\n    # Visit a parse tree produced by Cobol85Parser#startRule.\n    def visitStartRule(self, ctx:Cobol85Parser.StartRuleContext):\n        return self.visitChildren(ctx)\n    # Visit a parse tree produced by Cobol85Parser#compilationUnit.\n    def visitCompilationUnit(self, ctx:Cobol85Parser.CompilationUnitContext):\n        return self.visitChildren(ctx)\n    # Visit a parse tree produced by Cobol85Parser#programUnit.\n    def visitProgramUnit(self, ctx:Cobol85Parser.ProgramUnitContext):\n        return self.visitChildren(ctx)",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85Visitor",
        "documentation": {}
    },
    {
        "label": "Cobol85PreprocessorLexer",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorLexer",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorLexer",
        "peekOfCode": "class Cobol85PreprocessorLexer(Lexer):\n    atn = ATNDeserializer().deserialize(serializedATN())\n    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n    ADATA = 1\n    ADV = 2\n    ALIAS = 3\n    ANSI = 4\n    ANY = 5\n    APOST = 6\n    AR = 7",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorLexer",
        "documentation": {}
    },
    {
        "label": "serializedATN",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorLexer",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorLexer",
        "peekOfCode": "def serializedATN():\n    return [\n        4,0,292,2516,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,\n        5,2,6,7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,\n        2,13,7,13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,\n        7,19,2,20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,\n        2,26,7,26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,\n        7,32,2,33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,\n        2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,\n        7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorLexer",
        "documentation": {}
    },
    {
        "label": "Cobol85PreprocessorParse",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorParser",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorParser",
        "peekOfCode": "class Cobol85PreprocessorParser ( Parser ):\n    grammarFileName = \"Cobol85Preprocessor.g4\"\n    atn = ATNDeserializer().deserialize(serializedATN())\n    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n    sharedContextCache = PredictionContextCache()\n    literalNames = [ \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \n                     \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", ",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorParser",
        "documentation": {}
    },
    {
        "label": "serializedATN",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorParser",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorParser",
        "peekOfCode": "def serializedATN():\n    return [\n        4,1,292,678,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,\n        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,\n        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,\n        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,\n        26,2,27,7,27,2,28,7,28,2,29,7,29,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n        1,0,1,0,1,0,1,0,5,0,73,8,0,10,0,12,0,76,9,0,1,0,1,0,1,1,1,1,3,1,\n        82,8,1,1,1,1,1,4,1,86,8,1,11,1,12,1,87,1,2,1,2,1,2,1,2,3,2,94,8,\n        2,1,2,5,2,97,8,2,10,2,12,2,100,9,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorParser",
        "documentation": {}
    },
    {
        "label": "Cobol85PreprocessorListener",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorListener",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorListener",
        "peekOfCode": "class Cobol85PreprocessorListener(ParseTreeListener):\n    # Enter a parse tree produced by Cobol85PreprocessorParser#startRule.\n    def enterStartRule(self, ctx:Cobol85PreprocessorParser.StartRuleContext):\n        pass\n    # Exit a parse tree produced by Cobol85PreprocessorParser#startRule.\n    def exitStartRule(self, ctx:Cobol85PreprocessorParser.StartRuleContext):\n        pass\n    # Enter a parse tree produced by Cobol85PreprocessorParser#compilerOptions.\n    def enterCompilerOptions(self, ctx:Cobol85PreprocessorParser.CompilerOptionsContext):\n        pass",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorListener",
        "documentation": {}
    },
    {
        "label": "Cobol85PreprocessorVisitor",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorVisitor",
        "description": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorVisitor",
        "peekOfCode": "class Cobol85PreprocessorVisitor(ParseTreeVisitor):\n    # Visit a parse tree produced by Cobol85PreprocessorParser#startRule.\n    def visitStartRule(self, ctx:Cobol85PreprocessorParser.StartRuleContext):\n        return self.visitChildren(ctx)\n    # Visit a parse tree produced by Cobol85PreprocessorParser#compilerOptions.\n    def visitCompilerOptions(self, ctx:Cobol85PreprocessorParser.CompilerOptionsContext):\n        return self.visitChildren(ctx)\n    # Visit a parse tree produced by Cobol85PreprocessorParser#compilerXOpts.\n    def visitCompilerXOpts(self, ctx:Cobol85PreprocessorParser.CompilerXOptsContext):\n        return self.visitChildren(ctx)",
        "detail": "src.static_analysis.cobol_parser.grammars.Cobol85PreprocessorVisitor",
        "documentation": {}
    },
    {
        "label": "process_files",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.cobol_parser",
        "description": "src.static_analysis.cobol_parser.cobol_parser",
        "peekOfCode": "def process_files(file_pattern):\n    \"\"\"\n    Βρίσκει και επεξεργάζεται αρχεία COBOL με βάση το file_pattern.\n    :param file_pattern: Το όνομα αρχείου ή wildcard (π.χ. \"*.cbl\").\n    \"\"\"\n    # files = glob.glob(file_pattern) if not os.path.isfile(file_pattern) else [file_pattern]\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    pattern = os.path.join(script_dir, file_pattern)\n    files = glob.glob(pattern)\n    if not files:",
        "detail": "src.static_analysis.cobol_parser.cobol_parser",
        "documentation": {}
    },
    {
        "label": "process_cobol_file",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.cobol_parser",
        "description": "src.static_analysis.cobol_parser.cobol_parser",
        "peekOfCode": "def process_cobol_file(file_path, output_dir=\"output\"):\n    \"\"\" Κύρια συνάρτηση που εκτελεί όλη τη διαδικασία ανάλυσης \"\"\"\n    logger.info(f\"Processing file {file_path}...\")\n    input_stream = FileStream(file_path, encoding=\"utf-8\")\n    lexer = Cobol85Lexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = Cobol85Parser(token_stream)\n    # error_listener = CustomErrorListener()\n    # parser.removeErrorListeners()  # Αφαιρεί τον default listener\n    # parser.addErrorListener(error_listener)    ",
        "detail": "src.static_analysis.cobol_parser.cobol_parser",
        "documentation": {}
    },
    {
        "label": "save_analysis_to_file",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.cobol_parser",
        "description": "src.static_analysis.cobol_parser.cobol_parser",
        "peekOfCode": "def save_analysis_to_file(static_analysis, file_path, output_dir=\"output\"):\n    \"\"\" Αποθηκεύει τα αποτελέσματα της ανάλυσης σε JSON αρχείο \"\"\"\n    logger.info(f\"Saving file {file_path}...\")\n    file_name = os.path.basename(file_path)\n    file_name_without_ext = os.path.splitext(file_name)[0]\n    output_file = os.path.join(output_dir, f\"{file_name_without_ext}.json\")\n    json_output = static_analysis.to_json()\n    with open(output_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(json_output)\n    print(f\"Ανάλυση αποθηκεύτηκε στο: {output_file}\")",
        "detail": "src.static_analysis.cobol_parser.cobol_parser",
        "documentation": {}
    },
    {
        "label": "find_section",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.cobol_parser",
        "description": "src.static_analysis.cobol_parser.cobol_parser",
        "peekOfCode": "def find_section(section_class, ctx):\n    \"\"\"\n    Αναζητά αναδρομικά το WorkingStorageSection σε ένα υποδέντρο του parse tree.\n    \"\"\"\n    if ctx is None:\n        return None\n    # Αν ο κόμβος είναι ήδη WorkingStorageSection, επιστρέφουμε\n    if isinstance(ctx, section_class):\n        return ctx\n    # Αναζητάμε αναδρομικά σε όλους τους υποκόμβους",
        "detail": "src.static_analysis.cobol_parser.cobol_parser",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.cobol_parser",
        "description": "src.static_analysis.cobol_parser.cobol_parser",
        "peekOfCode": "def main():\n    \"\"\"\n    Ο κεντρικός έλεγχος για την εκτέλεση του parser, λαμβάνοντας input από το χρήστη.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"COBOL Static Analysis Parser\")\n    # Ορισμός argument για το όνομα αρχείου ή wildcard pattern\n    parser.add_argument(\"file_pattern\", help=\"Όνομα αρχείου COBOL ή wildcard pattern (π.χ. '*.cbl')\")\n    try:\n        args = parser.parse_args()\n        process_files(args.file_pattern)",
        "detail": "src.static_analysis.cobol_parser.cobol_parser",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.logger",
        "description": "src.static_analysis.cobol_parser.logger",
        "peekOfCode": "def setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup a logger\"\"\"\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    console_handler = logging.StreamHandler()\n    handler = logging.FileHandler(log_file)        \n    console_handler.setFormatter(formatter)\n    handler.setFormatter(formatter)\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    logger.addHandler(handler)",
        "detail": "src.static_analysis.cobol_parser.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.static_analysis.cobol_parser.logger",
        "description": "src.static_analysis.cobol_parser.logger",
        "peekOfCode": "logger = setup_logger('CobolParserLogger', 'cobol_parser.log')",
        "detail": "src.static_analysis.cobol_parser.logger",
        "documentation": {}
    },
    {
        "label": "get_children",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.context_info",
        "description": "src.static_analysis.cobol_parser.context_info",
        "peekOfCode": "def get_children(ctx) -> List:\n    \"\"\"\n    Επιστρέφει μια λίστα με όλα τα παιδικά nodes ενός context.\n    :param ctx: Το αντικείμενο context.\n    :return: Λίστα από child nodes.\n    \"\"\"\n    return list(ctx.getChildren())\ndef print_child(ctx) -> None:\n    \"\"\"\n    Εκτυπώνει το text του δεδομένου context.",
        "detail": "src.static_analysis.cobol_parser.context_info",
        "documentation": {}
    },
    {
        "label": "print_child",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.context_info",
        "description": "src.static_analysis.cobol_parser.context_info",
        "peekOfCode": "def print_child(ctx) -> None:\n    \"\"\"\n    Εκτυπώνει το text του δεδομένου context.\n    :param ctx: Το αντικείμενο context.\n    \"\"\"\n    logger.info(ctx.getText())\ndef get_child_text(ctx, idx: int) -> Optional[str]:\n    \"\"\"\n    Επιστρέφει το text του child node στη συγκεκριμένη θέση.\n    :param ctx: Το αντικείμενο context.",
        "detail": "src.static_analysis.cobol_parser.context_info",
        "documentation": {}
    },
    {
        "label": "get_child_text",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.context_info",
        "description": "src.static_analysis.cobol_parser.context_info",
        "peekOfCode": "def get_child_text(ctx, idx: int) -> Optional[str]:\n    \"\"\"\n    Επιστρέφει το text του child node στη συγκεκριμένη θέση.\n    :param ctx: Το αντικείμενο context.\n    :param idx: Η θέση του child node.\n    :return: Το text του child node ή None αν η θέση είναι εκτός ορίων.\n    \"\"\"\n    try:\n        return ctx.getChild(idx).getText()\n    except (IndexError, AttributeError):",
        "detail": "src.static_analysis.cobol_parser.context_info",
        "documentation": {}
    },
    {
        "label": "get_child_concatenated_text",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.context_info",
        "description": "src.static_analysis.cobol_parser.context_info",
        "peekOfCode": "def get_child_concatenated_text(ctx, idx: int) -> str:\n    \"\"\"\n    Επιστρέφει το concatenated text όλων των child nodes του συγκεκριμένου child node.\n    :param ctx: Το αντικείμενο context.\n    :param idx: Η θέση του child node.\n    :return: Concatenated text όλων των παιδιών, χωρισμένο με space.\n    \"\"\"\n    try:\n        ch = ctx.getChild(idx)\n        if ch.getChildCount() == 0:  # Αν δεν έχει παιδιά, επιστρέφουμε το δικό του text",
        "detail": "src.static_analysis.cobol_parser.context_info",
        "documentation": {}
    },
    {
        "label": "print_class_name",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.context_info",
        "description": "src.static_analysis.cobol_parser.context_info",
        "peekOfCode": "def print_class_name(obj):\n    \"\"\"\n    Debugging utility: Εκτυπώνει το όνομα της κλάσης ενός αντικειμένου.\n    :param obj: Το αντικείμενο που εξετάζεται.\n    \"\"\"\n    logger.info(obj.__class__.__name__)",
        "detail": "src.static_analysis.cobol_parser.context_info",
        "documentation": {}
    },
    {
        "label": "cobol_pic_to_c_type",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "description": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "peekOfCode": "def cobol_pic_to_c_type(pic):\n    \"\"\"\n    Μετατρέπει το COBOL PIC format σε C τύπο δεδομένων.\n    \"\"\"\n    if pic is None:\n        return \"void\"  # Αν δεν υπάρχει PIC, πιθανώς είναι struct container\n    # Χειρισμός string (PIC X(n))\n    match = re.match(r'X\\((\\d+)\\)', pic)\n    if match:\n        length = int(match.group(1))",
        "detail": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "documentation": {}
    },
    {
        "label": "convert_cobol_to_c",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "description": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "peekOfCode": "def convert_cobol_to_c(variables):\n    \"\"\"\n    Μετατρέπει λίστα COBOL variables σε C struct.\n    \"\"\"\n    struct_lines = [\"typedef struct {\"]\n    for var in variables:\n        c_type = cobol_pic_to_c_type(var[\"PIC\"])\n        var_name = var[\"Name\"] if var[\"Name\"] != \"FILLER\" else f\"unused_{id(var)}\"\n        # Αν υπάρχει OCCURS, τότε είναι array\n        if var[\"OCCURS\"]:",
        "detail": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "documentation": {}
    },
    {
        "label": "cobol_pic_to_json_type",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "description": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "peekOfCode": "def cobol_pic_to_json_type(pic):\n    \"\"\"\n    Μετατρέπει το COBOL PIC format σε JSON-compatible type.\n    \"\"\"\n    if pic is None:\n        return \"object\"  # Αν δεν υπάρχει PIC, πιθανώς είναι struct container\n    # Χειρισμός string (PIC X(n))\n    match = re.match(r'X\\((\\d+)\\)', pic)\n    if match:\n        return {\"type\": \"string\", \"length\": int(match.group(1))}",
        "detail": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "documentation": {}
    },
    {
        "label": "convert_cobol_to_json",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "description": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "peekOfCode": "def convert_cobol_to_json(variables):\n    \"\"\"\n    Μετατρέπει COBOL variables σε δομή JSON με nested records.\n    \"\"\"\n    json_structure = []\n    record_stack = []  # Stack για nested structures\n    for var in variables:\n        json_entry = {\n            \"name\": var[\"Name\"] if var[\"Name\"] != \"FILLER\" else f\"unused_{id(var)}\",\n            \"level\": int(var[\"Level\"]),",
        "detail": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "documentation": {}
    },
    {
        "label": "variables",
        "kind": 5,
        "importPath": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "description": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "peekOfCode": "variables = [{'Level': '77', 'Name': 'RC', 'PIC': 'S9(4)', 'VALUE': '+0', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '77', 'Name': 'SYSOUT-TOKEN', 'PIC': 'X(8)', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'DOGEMSG', 'PIC': None, 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DOGEID', 'PIC': 'X(10)B', 'VALUE': \"'DOGECICS99'\", 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'ADDRSS', 'PIC': 'X(34)B', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'AMOUNT', 'PIC': 'Z(02),Z(03),Z(02)9.9(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'DOGEMSG-LEN', 'PIC': '99', 'VALUE': '61', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'TRANSACTION', 'PIC': None, 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'TDATE', 'PIC': 'X(10)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'NUM-DATE', 'PIC': '9(10)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': 'TDATE', 'CONDITIONS': []}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'TADDRSS', 'PIC': 'X(34)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'TLABEL', 'PIC': 'X(10)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'TAMOUNT', 'PIC': None, 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '10', 'Name': 'TAMT-SIGN', 'PIC': 'X', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': [{'Level': '88', 'Name': 'TAMT-SIGN-POSITIVE', 'VALUE': \"'+'\"}, {'Level': '88', 'Name': 'TAMT-SIGN-NEGATIVE', 'VALUE': \"'-'\"}]}, {'Level': '10', 'Name': 'TAMT-INTEGER-PART', 'PIC': 'X(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '10', 'Name': 'TAMT-DEC-POINT', 'PIC': 'X', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '10', 'Name': 'TAMT-DECIMAL-PART', 'PIC': 'X(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'THE-AMOUNT', 'PIC': 'S9(8)V9(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'FILLER', 'PIC': None, 'VALUE': None, 'OCCURS': None, 'REDEFINES': 'THE-AMOUNT', 'CONDITIONS': []}, {'Level': '05', 'Name': 'THE-AMOUNT-INTEGER', 'PIC': 'X(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'THE-AMOUNT-DECIMAL', 'PIC': 'S9(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'AVAILABLE-AMOUNT', 'PIC': 'S9(8)V9(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'RECENT-COLOR', 'PIC': 'X', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'DISPLAY-TRAN', 'PIC': None, 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DDATE', 'PIC': 'X(10)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DLABEL', 'PIC': 'X(10)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DSIGN', 'PIC': 'X', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DAMOUNT', 'PIC': 'Z(02),Z(03),Z(02)9.9(8)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DTYPE', 'PIC': 'XXXX', 'VALUE': \"'DOGE'\", 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'TEMP-DATE', 'PIC': '9(15)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'DOGEMSG-LEN', 'PIC': '99', 'VALUE': '61', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'START-RECORD-ID', 'PIC': '9(10)', 'VALUE': '9999999999', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'SINCE-EPOCH', 'PIC': 'S9(15)', 'VALUE': '+2208988800000', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'RESPONSE-CODE', 'PIC': 'S9(4)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'RESPONSE-CODE2', 'PIC': 'S9(4)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'DOGECOMMS-AREA', 'PIC': None, 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '05', 'Name': 'DOGE-FLAG', 'PIC': 'X', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': [{'Level': '88', 'Name': 'SUCH-DOGE', 'VALUE': \"'D'\"}, {'Level': '88', 'Name': 'WOW-MENU', 'VALUE': \"'W'\"}, {'Level': '88', 'Name': 'SUCH-SEND', 'VALUE': \"'S'\"}, {'Level': '88', 'Name': 'SUCH-HISTORY', 'VALUE': \"'T'\"}]}, {'Level': '05', 'Name': 'FILLER', 'PIC': 'X(9)', 'VALUE': None, 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}, {'Level': '01', 'Name': 'WTO-MESSAGE', 'PIC': 'X(38)', 'VALUE': 'SPACES', 'OCCURS': None, 'REDEFINES': None, 'CONDITIONS': []}]\ndef cobol_pic_to_json_type(pic):\n    \"\"\"\n    Μετατρέπει το COBOL PIC format σε JSON-compatible type.\n    \"\"\"\n    if pic is None:\n        return \"object\"  # Αν δεν υπάρχει PIC, πιθανώς είναι struct container\n    # Χειρισμός string (PIC X(n))\n    match = re.match(r'X\\((\\d+)\\)', pic)\n    if match:",
        "detail": "src.static_analysis.cobol_parser.convert_to_c_structs",
        "documentation": {}
    },
    {
        "label": "CustomErrorListener",
        "kind": 6,
        "importPath": "src.static_analysis.cobol_parser.custom_error_listener",
        "description": "src.static_analysis.cobol_parser.custom_error_listener",
        "peekOfCode": "class CustomErrorListener(ErrorListener):\n    def __init__(self):\n        super(CustomErrorListener, self).__init__()\n        self.errors = []\n    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):\n        self.errors.append(f\"Line {line}:{column} - {msg}\")\n    def get_errors(self):\n        return self.errors",
        "detail": "src.static_analysis.cobol_parser.custom_error_listener",
        "documentation": {}
    },
    {
        "label": "create_output_dir",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_cobol",
        "description": "src.static_analysis.cobol_parser.parse_cobol",
        "peekOfCode": "def create_output_dir(output_dir=\"output\"):\n    \"\"\" Δημιουργεί τον φάκελο εξόδου αν δεν υπάρχει \"\"\"\n    os.makedirs(output_dir, exist_ok=True)\n    return output_dir\n# def parse_cobol_file(file_path):\n#     \"\"\" Διαβάζει ένα COBOL αρχείο και δημιουργεί το συντακτικό του δέντρο \"\"\"\n#     logger.info(f\"Processing file {file_path}...\")\n#     input_stream = FileStream(file_path, encoding=\"utf-8\")\n#     lexer = Cobol85Lexer(input_stream)\n#     token_stream = CommonTokenStream(lexer)",
        "detail": "src.static_analysis.cobol_parser.parse_cobol",
        "documentation": {}
    },
    {
        "label": "save_analysis_to_file",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_cobol",
        "description": "src.static_analysis.cobol_parser.parse_cobol",
        "peekOfCode": "def save_analysis_to_file(static_analysis, file_path, output_dir=\"output\"):\n    \"\"\" Αποθηκεύει τα αποτελέσματα της ανάλυσης σε JSON αρχείο \"\"\"\n    logger.info(f\"Saving file {file_path}...\")\n    file_name = os.path.basename(file_path)\n    file_name_without_ext = os.path.splitext(file_name)[0]\n    output_file = os.path.join(output_dir, f\"{file_name_without_ext}.json\")\n    json_output = static_analysis.to_json()\n    with open(output_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(json_output)\n    print(f\"Ανάλυση αποθηκεύτηκε στο: {output_file}\")",
        "detail": "src.static_analysis.cobol_parser.parse_cobol",
        "documentation": {}
    },
    {
        "label": "generate_diagrams",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_cobol",
        "description": "src.static_analysis.cobol_parser.parse_cobol",
        "peekOfCode": "def generate_diagrams(static_analysis):\n    \"\"\" Δημιουργεί Flowchart και BPMN διαγράμματα \"\"\"\n    pass\n    # if static_analysis:\n        # diagram = FlowChartGenerator()\n        # diagram.genrateDiagram(static_analysis, \"RECEIVE-OPTION\")\ndef process_cobol_file(file_path, output_dir=\"output\"):\n    \"\"\" Κύρια συνάρτηση που εκτελεί όλη τη διαδικασία ανάλυσης \"\"\"\n    logger.info(f\"Processing file {file_path}...\")\n    input_stream = FileStream(file_path, encoding=\"utf-8\")",
        "detail": "src.static_analysis.cobol_parser.parse_cobol",
        "documentation": {}
    },
    {
        "label": "process_cobol_file",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_cobol",
        "description": "src.static_analysis.cobol_parser.parse_cobol",
        "peekOfCode": "def process_cobol_file(file_path, output_dir=\"output\"):\n    \"\"\" Κύρια συνάρτηση που εκτελεί όλη τη διαδικασία ανάλυσης \"\"\"\n    logger.info(f\"Processing file {file_path}...\")\n    input_stream = FileStream(file_path, encoding=\"utf-8\")\n    lexer = Cobol85Lexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = Cobol85Parser(token_stream)\n    # error_listener = CustomErrorListener()\n    # parser.removeErrorListeners()  # Αφαιρεί τον default listener\n    # parser.addErrorListener(error_listener)    ",
        "detail": "src.static_analysis.cobol_parser.parse_cobol",
        "documentation": {}
    },
    {
        "label": "find_section",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_cobol",
        "description": "src.static_analysis.cobol_parser.parse_cobol",
        "peekOfCode": "def find_section(section_class, ctx):\n    \"\"\"\n    Αναζητά αναδρομικά το WorkingStorageSection σε ένα υποδέντρο του parse tree.\n    \"\"\"\n    if ctx is None:\n        return None\n    # Αν ο κόμβος είναι ήδη WorkingStorageSection, επιστρέφουμε\n    if isinstance(ctx, section_class):\n        return ctx\n    # Αναζητάμε αναδρομικά σε όλους τους υποκόμβους",
        "detail": "src.static_analysis.cobol_parser.parse_cobol",
        "documentation": {}
    },
    {
        "label": "parse_identification_division_section",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def parse_identification_division_section(ctx):\n    \"\"\"\n    Αναλύει το IDENTIFICATION DIVISION και επιστρέφει τα αποτελέσματα.\n    \"\"\"\n    logger.info(\"Processing IDENTIFICATION DIVISION...\")\n    static_analysis = StaticAnalysis()\n    logger.info(f\"\\t{ctx.__class__.__name__}\")\n    for child in ctx.children:\n        logger.info(f\"\\t{child.__class__.__name__}\")\n        if isinstance(child, Cobol85Parser.ProgramIdParagraphContext):",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "process_identification_body",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def process_identification_body(ctx, static_analysis):\n    \"\"\"\n    Αναλύει το IdentificationDivisionBody και εξάγει πληροφορίες όπως Author, Installation, DateWritten, Security.\n    \"\"\"\n    for sub_child in ctx.children:\n        if isinstance(sub_child, Cobol85Parser.AuthorParagraphContext):\n            static_analysis.Author = visit_author_paragraph(sub_child)\n        elif isinstance(sub_child, Cobol85Parser.InstallationParagraphContext):\n            static_analysis.Installation = visit_installation_paragraph(sub_child)\n        elif isinstance(sub_child, Cobol85Parser.DateWrittenParagraphContext):",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "visit_program_id_paragraph",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def visit_program_id_paragraph(ctx):\n    \"\"\"\n    Επιστρέφει το Program-ID από το αντίστοιχο context.\n    \"\"\"\n    logger.info(f\"\\t\\t{ctx.__class__.__name__}\")\n    return ctx.getChild(2).getText().strip() if ctx.getChildCount() > 2 else \"\"\ndef visit_author_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_installation_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "visit_author_paragraph",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def visit_author_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_installation_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_date_written_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_security_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef extract_value_from_identification_line(line):\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "visit_installation_paragraph",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def visit_installation_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_date_written_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_security_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef extract_value_from_identification_line(line):\n    \"\"\"\n    Εξάγει την πληροφορία μετά την πρώτη τελεία `.` στη γραμμή.\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "visit_date_written_paragraph",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def visit_date_written_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef visit_security_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef extract_value_from_identification_line(line):\n    \"\"\"\n    Εξάγει την πληροφορία μετά την πρώτη τελεία `.` στη γραμμή.\n    \"\"\"\n    parts = line.split(\".\", 1)\n    value = parts[1].strip() if len(parts) > 1 else \"\"",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "visit_security_paragraph",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def visit_security_paragraph(ctx):\n    return extract_value_from_identification_line(ctx.getText().strip())\ndef extract_value_from_identification_line(line):\n    \"\"\"\n    Εξάγει την πληροφορία μετά την πρώτη τελεία `.` στη γραμμή.\n    \"\"\"\n    parts = line.split(\".\", 1)\n    value = parts[1].strip() if len(parts) > 1 else \"\"\n    return value[:-1] if value.endswith(\".\") else value",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "extract_value_from_identification_line",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_identification_division",
        "description": "src.static_analysis.cobol_parser.parse_identification_division",
        "peekOfCode": "def extract_value_from_identification_line(line):\n    \"\"\"\n    Εξάγει την πληροφορία μετά την πρώτη τελεία `.` στη γραμμή.\n    \"\"\"\n    parts = line.split(\".\", 1)\n    value = parts[1].strip() if len(parts) > 1 else \"\"\n    return value[:-1] if value.endswith(\".\") else value",
        "detail": "src.static_analysis.cobol_parser.parse_identification_division",
        "documentation": {}
    },
    {
        "label": "parse_linkage_section",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def parse_linkage_section(ctx, static_analysis):\n    \"\"\"\n    Αναλύει το LINKAGE SECTION και εξάγει τις δηλώσεις μεταβλητών.\n    Υποστηρίζει `REDEFINES`, `OCCURS`, `88 LEVEL` conditions.\n    :param ctx: Το parse tree context του LINKAGE SECTION.\n    :return: Μια λίστα με μεταβλητές που δηλώθηκαν.\n    \"\"\"\n    variables = []\n    parent_entry = None\n    if ctx is None: ",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "visit_data_description_entry",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def visit_data_description_entry(ctx):\n    \"\"\"\n    Επεξεργάζεται κάθε εγγραφή στο LINKAGE SECTION.\n    :param ctx: Το parse tree context του DataDescriptionEntry.\n    :return: Dictionary με τις πληροφορίες της μεταβλητής.\n    \"\"\"\n    var_entry = {\n        \"Level\": None,\n        \"Name\": None,\n        \"PIC\": None,",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "visit_picture_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def visit_picture_clause(ctx):\n    return ctx.getText().replace(\"PIC\", \"\").strip()\ndef visit_value_clause(ctx):\n    return ctx.getText().replace(\"VALUE\", \"\").strip()\ndef visit_occurs_clause(ctx):\n    return ctx.getText().replace(\"OCCURS\", \"\").strip()\ndef visit_redefines_clause(ctx):\n    return ctx.getText().replace(\"REDEFINES\", \"\").strip()\ndef visit_condition_clause(ctx):\n    \"\"\" ",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "visit_value_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def visit_value_clause(ctx):\n    return ctx.getText().replace(\"VALUE\", \"\").strip()\ndef visit_occurs_clause(ctx):\n    return ctx.getText().replace(\"OCCURS\", \"\").strip()\ndef visit_redefines_clause(ctx):\n    return ctx.getText().replace(\"REDEFINES\", \"\").strip()\ndef visit_condition_clause(ctx):\n    \"\"\" \n    Επεξεργάζεται τα 88 LEVEL condition names και τις τιμές τους.\n    :param ctx: Το parse tree context του 88 LEVEL condition.",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "visit_occurs_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def visit_occurs_clause(ctx):\n    return ctx.getText().replace(\"OCCURS\", \"\").strip()\ndef visit_redefines_clause(ctx):\n    return ctx.getText().replace(\"REDEFINES\", \"\").strip()\ndef visit_condition_clause(ctx):\n    \"\"\" \n    Επεξεργάζεται τα 88 LEVEL condition names και τις τιμές τους.\n    :param ctx: Το parse tree context του 88 LEVEL condition.\n    :return: Dictionary με το condition και το VALUE του.\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "visit_redefines_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def visit_redefines_clause(ctx):\n    return ctx.getText().replace(\"REDEFINES\", \"\").strip()\ndef visit_condition_clause(ctx):\n    \"\"\" \n    Επεξεργάζεται τα 88 LEVEL condition names και τις τιμές τους.\n    :param ctx: Το parse tree context του 88 LEVEL condition.\n    :return: Dictionary με το condition και το VALUE του.\n    \"\"\"\n    condition = {\"Level\": \"88\", \"Name\": None, \"VALUE\": None}\n    for child in context_info.get_children(ctx):",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "visit_condition_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def visit_condition_clause(ctx):\n    \"\"\" \n    Επεξεργάζεται τα 88 LEVEL condition names και τις τιμές τους.\n    :param ctx: Το parse tree context του 88 LEVEL condition.\n    :return: Dictionary με το condition και το VALUE του.\n    \"\"\"\n    condition = {\"Level\": \"88\", \"Name\": None, \"VALUE\": None}\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ConditionNameContext):\n            condition[\"Name\"] = child.getText()",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "get_linkage_json",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_linkage",
        "description": "src.static_analysis.cobol_parser.parse_linkage",
        "peekOfCode": "def get_linkage_json(variables):\n    \"\"\" Επιστρέφει τις μεταβλητές του LINKAGE SECTION σε JSON. \"\"\"\n    return json.dumps(variables, indent=4)",
        "detail": "src.static_analysis.cobol_parser.parse_linkage",
        "documentation": {}
    },
    {
        "label": "parse_procedure_division_section",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def parse_procedure_division_section(ctx, static_analysis):\n    \"\"\"\n    Επισκέπτεται το PROCEDURE DIVISION και αναλύει το περιεχόμενο του.\n    \"\"\"\n    logger.info(\"-------visit_procedure_division-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ProcedureDivisionBodyContext):\n            logger.info(\"===================================================\")\n            visit_procedure_division_body(child, static_analysis)\n    logger.info(\"-------End of ProcedureDivision-----------\")",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "visit_procedure_division_body",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def visit_procedure_division_body(ctx, static_analysis):\n    \"\"\"\n    Επισκέπτεται το ProcedureDivisionBody και αναλύει τις παραγράφους.\n    \"\"\"\n    # logger.info(\"-------visit_procedure_division_body-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ParagraphsContext):\n            visit_paragraphs_context(child, static_analysis)\ndef visit_paragraphs_context(ctx, static_analysis):\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "visit_paragraphs_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def visit_paragraphs_context(ctx, static_analysis):\n    \"\"\"\n    Επισκέπτεται τις παραγράφους μέσα στο PROCEDURE DIVISION.\n    \"\"\"\n    # logger.info(\"-------visit_paragraphs_context-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ParagraphContext):\n            visit_paragraph_context(child, static_analysis)\ndef visit_paragraph_context(ctx, static_analysis):\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "visit_paragraph_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def visit_paragraph_context(ctx, static_analysis):\n    \"\"\"\n    Επισκέπτεται μια παράγραφο και εξάγει τα δεδομένα της.\n    \"\"\"\n    # logger.info(\"-------visit_paragraph_context-----------\")\n    flow = Flow()\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ParagraphNameContext):\n            flow.Name = visit_paragraph_name_context(child)\n        if isinstance(child, Cobol85Parser.SentenceContext):",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "visit_paragraph_name_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def visit_paragraph_name_context(ctx):\n    \"\"\"\n    Επιστρέφει το όνομα της παραγράφου.\n    \"\"\"\n    # logger.info(\"-------visit_paragraph_name_context-----------\")\n    return ctx.getChild(0).getText()\ndef visit_sentence_context(ctx, flow):\n    \"\"\"\n    Επισκέπτεται τις προτάσεις (sentences) μιας παραγράφου.\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "visit_sentence_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def visit_sentence_context(ctx, flow):\n    \"\"\"\n    Επισκέπτεται τις προτάσεις (sentences) μιας παραγράφου.\n    \"\"\"\n    # logger.info(\"-------visit_sentence_context-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.StatementContext):\n            visit_statement_context(child, flow)\ndef visit_statement_context(ctx, flow):\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "visit_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_procedure_division",
        "description": "src.static_analysis.cobol_parser.parse_procedure_division",
        "peekOfCode": "def visit_statement_context(ctx, flow):\n    \"\"\"\n    Καλεί τον parser για statements και προσθέτει το αποτέλεσμα στη ροή.\n    \"\"\"\n    statement = parse_statements.parse_statement(ctx)\n    if statement is not None:\n        flow.addSentence(statement)",
        "detail": "src.static_analysis.cobol_parser.parse_procedure_division",
        "documentation": {}
    },
    {
        "label": "parse_statement",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def parse_statement(ctx):\n    \"\"\"\n    Επισκέπτεται ένα Statement node και επιστρέφει το αντίστοιχο statement object.\n    \"\"\"\n    # logger.info(\"-------visitStatementContext-----------\")\n    statement_map = {\n        Cobol85Parser.MoveStatementContext: visit_move_statement_context,\n        Cobol85Parser.PerformStatementContext: visit_perform_statement_context,\n        Cobol85Parser.GobackStatementContext: visit_goback_statement_context,\n        Cobol85Parser.IfStatementContext: visit_if_statement_context,",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_if_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_if_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα IF statement. \"\"\"\n    # logger.info(\"-------visitIfStatementContext-----------\")\n    conditional_statement = ConditionalStatement(methodName=f\"IF {context_info.get_child_concatenated_text(ctx, 1)}\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.IfThenContext):\n            visit_if_then_context(child, conditional_statement)\n        elif isinstance(child, Cobol85Parser.IfElseContext):\n            visit_if_else_context(child, conditional_statement)\n    return conditional_statement",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_if_then_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_if_then_context(ctx, conditional_statement):\n    \"\"\" Επεξεργάζεται το THEN μέρος του IF. \"\"\"\n    # logger.info(\"-------visitIfThenContext-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.CombinableConditionContext):\n            condition = visit_combinable_condition_context(child)\n            if condition:\n                conditional_statement.addClause(condition)\n        elif isinstance(child, Cobol85Parser.StatementContext):\n            statement = parse_statement(child)",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_if_else_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_if_else_context(ctx, conditional_statement):\n    \"\"\" Επεξεργάζεται το ELSE μέρος του IF. \"\"\"\n    # logger.info(\"-------visitIfElseContext-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.StatementContext):\n            statement = parse_statement(child)\n            if statement:\n                conditional_statement.addFalseStatement(statement)\n# ----------------------------------------------------\n# Conditions",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_combinable_condition_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_combinable_condition_context(ctx):\n    \"\"\" Επεξεργάζεται συνδυασμένες συνθήκες (AND, OR). \"\"\"\n    # logger.info(\"-------visitCombinableConditionContext-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.SimpleConditionContext):\n            return visit_simple_condition_context(child)\n    return None\ndef visit_simple_condition_context(ctx):\n    \"\"\" Επεξεργάζεται μία απλή συνθήκη (π.χ. X > 5). \"\"\"\n    # logger.info(\"-------visitSimpleConditionContext-----------\")",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_simple_condition_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_simple_condition_context(ctx):\n    \"\"\" Επεξεργάζεται μία απλή συνθήκη (π.χ. X > 5). \"\"\"\n    # logger.info(\"-------visitSimpleConditionContext-----------\")\n    conditional_statement = ConditionalStatement(methodName=\"IF\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.RelationConditionContext):\n            clause = visit_relation_condition_context(child)\n            if clause:\n                conditional_statement.addClause(clause)\n    return conditional_statement",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_relation_condition_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_relation_condition_context(ctx):\n    \"\"\" Επεξεργάζεται συνθήκες σύγκρισης (π.χ. X = Y). \"\"\"\n    # logger.info(\"-------visitRelationConditionContext-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.RelationArithmeticComparisonContext):\n            return visit_relation_arithmetic_comparison_context(child)\ndef visit_relation_arithmetic_comparison_context(ctx):\n    \"\"\" Επεξεργάζεται αριθμητικές συγκρίσεις (π.χ. A > B). \"\"\"\n    # logger.info(\"-------visitRelationArithmeticComparisonContext-----------\")\n    return ConditionClause(",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_relation_arithmetic_comparison_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_relation_arithmetic_comparison_context(ctx):\n    \"\"\" Επεξεργάζεται αριθμητικές συγκρίσεις (π.χ. A > B). \"\"\"\n    # logger.info(\"-------visitRelationArithmeticComparisonContext-----------\")\n    return ConditionClause(\n        Left=context_info.get_child_text(ctx, 0),\n        Operator=context_info.get_child_concatenated_text(ctx, 1),\n        Right=context_info.get_child_text(ctx, 2)\n    )\n# ----------------------------------------------------\n# MOVE Statements",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_move_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_move_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα MOVE statement και επιστρέφει ένα AssignStatement. \"\"\"\n    # logger.info(\"-------visitMoveStatementContext-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.MoveToStatementContext):\n            move_sentence = visit_move_to_statement_context(child)\n            assignFrom = move_sentence.AssignFrom\n            assignTo = move_sentence.AssignTo\n            return AssignStatement(methodName=f\"Assign value to {assignTo}\", AssignFrom=assignFrom, AssignTo=assignTo)\n    return None",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_move_to_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_move_to_statement_context(ctx):\n    \"\"\" Επεξεργάζεται το MOVE TO μέρος ενός statement. \"\"\"\n    assignFrom = None\n    assignTo = None\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.IdentifierContext):\n            assignTo = visit_identifier_context(child)\n        elif isinstance(child, Cobol85Parser.MoveToSendingAreaContext):\n            assignFrom = visit_move_to_sending_area_context(child)\n    if assignFrom and assignTo:",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_identifier_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_identifier_context(ctx):\n    \"\"\" Επιστρέφει το text του identifier. \"\"\"\n    return ctx.getChild(0).getText() if ctx.getChildCount() > 0 else \"\"\ndef visit_move_to_sending_area_context(ctx):\n    \"\"\" Επιστρέφει το text του sending area. \"\"\"\n    return ctx.getChild(0).getText() if ctx.getChildCount() > 0 else \"\"\n# ----------------------------------------------------\n# PERFORM Statements\n# ----------------------------------------------------\ndef visit_perform_statement_context(ctx):",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_move_to_sending_area_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_move_to_sending_area_context(ctx):\n    \"\"\" Επιστρέφει το text του sending area. \"\"\"\n    return ctx.getChild(0).getText() if ctx.getChildCount() > 0 else \"\"\n# ----------------------------------------------------\n# PERFORM Statements\n# ----------------------------------------------------\ndef visit_perform_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα PERFORM statement. \"\"\"\n    # logger.info(\"-------visitPerformStatementContext-----------\")\n    for child in context_info.get_children(ctx):",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_perform_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_perform_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα PERFORM statement. \"\"\"\n    # logger.info(\"-------visitPerformStatementContext-----------\")\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.PerformProcedureStatementContext):\n            return visit_perform_procedure_statement_context(child)\n    return None\ndef visit_perform_procedure_statement_context(ctx):\n    \"\"\" Επιστρέφει την διαδικασία που εκτελείται στο PERFORM. \"\"\"\n    return CallStatement(methodName=ctx.getText())",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_perform_procedure_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_perform_procedure_statement_context(ctx):\n    \"\"\" Επιστρέφει την διαδικασία που εκτελείται στο PERFORM. \"\"\"\n    return CallStatement(methodName=ctx.getText())\n# ----------------------------------------------------\n# EXEC CICS Statements\n# ----------------------------------------------------\ndef visit_exec_cics_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα EXEC CICS statement. \"\"\"\n    # call_statement = CallStatement(False)\n    for child in context_info.get_children(ctx):",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_exec_cics_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_exec_cics_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα EXEC CICS statement. \"\"\"\n    # call_statement = CallStatement(False)\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ExecCicsCommandContext):\n            call_statement = visit_exec_cics_command_context(child)\n            # command_name, params = visit_exec_cics_command_context(child)\n            # logger.info(f\"----------------------------______{child.getText()}_______--------------------\")\n            # logger.info(params)\n            # logger.info(\"----------------------------_________________________________________--------------------\")            ",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_exec_cics_command_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_exec_cics_command_context(ctx):\n    \"\"\" Επεξεργάζεται τις εντολές μέσα σε ένα EXEC CICS statement. \"\"\"\n    # context_info.print_class_name(ctx)\n    children = context_info.get_children(ctx)\n    if not children:\n        return \"\", []\n    call_statement = CallStatement(False)    \n    command_name = children[0].getText()\n    logger.debug(f\"command Name: {children[0].getText()}\")\n    call_statement.methodName = children[0].getText()",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "visit_goback_statement_context",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_statements",
        "description": "src.static_analysis.cobol_parser.parse_statements",
        "peekOfCode": "def visit_goback_statement_context(ctx):\n    \"\"\" Επεξεργάζεται ένα GOBACK statement. \"\"\"\n    return CallStatement(methodName=\"GOBACK\")",
        "detail": "src.static_analysis.cobol_parser.parse_statements",
        "documentation": {}
    },
    {
        "label": "parse_working_storage_section",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def parse_working_storage_section(ctx, static_analysis):\n    \"\"\"\n    Αναλύει το WORKING-STORAGE SECTION και εξάγει τις δηλώσεις μεταβλητών.\n    Υποστηρίζει `REDEFINES`, `OCCURS`, και `88 LEVEL` conditions.\n    :param ctx: Το parse tree context του WORKING-STORAGE SECTION.\n    :return: Μια λίστα με μεταβλητές που δηλώθηκαν.\n    \"\"\"\n    # workingStorageTree = find_working_storage_section(ctx)\n    variables = []\n    parent_entry = None  # Για να διατηρούμε parent για τα 88 LEVEL conditions",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "visit_data_description_entry",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def visit_data_description_entry(ctx):\n    \"\"\"\n    Επεξεργάζεται κάθε εγγραφή περιγραφής δεδομένων (μεταβλητή).\n    :param ctx: Το parse tree context του DataDescriptionEntry.\n    :return: Ένα dictionary με τις πληροφορίες της μεταβλητής.\n    \"\"\"\n    var_entry = {\n        \"Level\": None,\n        \"Name\": None,\n        \"PIC\": None,",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "get_value",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def get_value(ctx) -> str:\n    \"\"\" Εξάγει την `PIC` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()\n    else:\n        return \"\"\ndef visit_picture_clause(ctx) -> str:\n    \"\"\" Εξάγει την `PIC` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "visit_picture_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def visit_picture_clause(ctx) -> str:\n    \"\"\" Εξάγει την `PIC` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()\n    else:\n        return \"\"\ndef visit_value_clause(ctx) -> str:\n    \"\"\" Εξάγει την `VALUE` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "visit_value_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def visit_value_clause(ctx) -> str:\n    \"\"\" Εξάγει την `VALUE` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()\n    else:\n        return \"\"\ndef visit_occurs_clause(ctx) -> str:\n    \"\"\" Εξάγει την `OCCURS` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "visit_occurs_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def visit_occurs_clause(ctx) -> str:\n    \"\"\" Εξάγει την `OCCURS` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()\n    else:\n        return \"\"\ndef visit_redefines_clause(ctx) -> str:\n    \"\"\" Εξάγει την `REDEFINES` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "visit_redefines_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def visit_redefines_clause(ctx) -> str:\n    \"\"\" Εξάγει την `REDEFINES` δήλωση. \"\"\"\n    if ctx.getChildCount() > 1:\n        return ctx.getChild(1).getText().strip()\n    else:\n        return \"\"\ndef visit_condition_clause(ctx):\n    \"\"\" \n    Επεξεργάζεται τα 88 LEVEL condition names και τις τιμές τους.\n    :param ctx: Το parse tree context του 88 LEVEL condition.",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "visit_condition_clause",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def visit_condition_clause(ctx):\n    \"\"\" \n    Επεξεργάζεται τα 88 LEVEL condition names και τις τιμές τους.\n    :param ctx: Το parse tree context του 88 LEVEL condition.\n    :return: Ένα dictionary με το condition και το VALUE του.\n    \"\"\"\n    condition = {\"Level\": \"88\", \"Name\": None, \"VALUE\": None}\n    for child in context_info.get_children(ctx):\n        if isinstance(child, Cobol85Parser.ConditionNameContext):\n            condition[\"Name\"] = child.getText()",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "get_variables_json",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def get_variables_json(variables) -> str:\n    \"\"\" Επιστρέφει τις μεταβλητές σε μορφή JSON. \"\"\"\n    return json.dumps(variables, indent=4)\ndef get_variables_raw(variables) -> str:\n    \"\"\" Επιστρέφει τις μεταβλητές σε μορφή JSON. \"\"\"\n    return variables    \ndef variables_to_json(variables) -> str:\n    \"\"\" Επιστρέφει τις μεταβλητές σε μορφή JSON. \"\"\"\n    return convert_cobol_to_json(variables)\ndef cobol_pic_to_json_type(pic):",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "get_variables_raw",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def get_variables_raw(variables) -> str:\n    \"\"\" Επιστρέφει τις μεταβλητές σε μορφή JSON. \"\"\"\n    return variables    \ndef variables_to_json(variables) -> str:\n    \"\"\" Επιστρέφει τις μεταβλητές σε μορφή JSON. \"\"\"\n    return convert_cobol_to_json(variables)\ndef cobol_pic_to_json_type(pic):\n    \"\"\"\n    Μετατρέπει το COBOL PIC format σε JSON-compatible type.\n    \"\"\"",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "variables_to_json",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def variables_to_json(variables) -> str:\n    \"\"\" Επιστρέφει τις μεταβλητές σε μορφή JSON. \"\"\"\n    return convert_cobol_to_json(variables)\ndef cobol_pic_to_json_type(pic):\n    \"\"\"\n    Μετατρέπει το COBOL PIC format σε JSON-compatible type.\n    \"\"\"\n    if pic is None:\n        return \"object\"  # Αν δεν υπάρχει PIC, πιθανώς είναι struct container\n    # Χειρισμός string (PIC X(n))",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "cobol_pic_to_json_type",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def cobol_pic_to_json_type(pic):\n    \"\"\"\n    Μετατρέπει το COBOL PIC format σε JSON-compatible type.\n    \"\"\"\n    if pic is None:\n        return \"object\"  # Αν δεν υπάρχει PIC, πιθανώς είναι struct container\n    # Χειρισμός string (PIC X(n))\n    match = re.match(r'X\\((\\d+)\\)', pic)\n    if match:\n        return {\"type\": \"string\", \"length\": int(match.group(1))}",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "convert_cobol_to_json",
        "kind": 2,
        "importPath": "src.static_analysis.cobol_parser.parse_working_storage",
        "description": "src.static_analysis.cobol_parser.parse_working_storage",
        "peekOfCode": "def convert_cobol_to_json(variables):\n    \"\"\"\n    Μετατρέπει COBOL variables σε δομή JSON με nested records.\n    \"\"\"\n    json_structure = []\n    record_stack = []  # Stack για nested structures\n    for var in variables:\n        json_entry = {\n            \"name\": var[\"Name\"] if var[\"Name\"] != \"FILLER\" else f\"unused_{id(var)}\",\n            \"level\": int(var[\"Level\"]),",
        "detail": "src.static_analysis.cobol_parser.parse_working_storage",
        "documentation": {}
    },
    {
        "label": "get_neo4j_driver",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_connection",
        "description": "src.static_analysis.process_results.db_connection",
        "peekOfCode": "def get_neo4j_driver():\n    return GraphDatabase.driver(NEO4J_URI, auth=(USERNAME, PASSWORD))",
        "detail": "src.static_analysis.process_results.db_connection",
        "documentation": {}
    },
    {
        "label": "NEO4J_URI",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.db_connection",
        "description": "src.static_analysis.process_results.db_connection",
        "peekOfCode": "NEO4J_URI = \"neo4j+s://37866975.databases.neo4j.io\"\nUSERNAME = \"neo4j\"\nPASSWORD = \"C7fZBkKEKGnoD5N2vqOgeWrXl3vsGR8cWbo3lTxivVI\"\ndef get_neo4j_driver():\n    return GraphDatabase.driver(NEO4J_URI, auth=(USERNAME, PASSWORD))",
        "detail": "src.static_analysis.process_results.db_connection",
        "documentation": {}
    },
    {
        "label": "USERNAME",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.db_connection",
        "description": "src.static_analysis.process_results.db_connection",
        "peekOfCode": "USERNAME = \"neo4j\"\nPASSWORD = \"C7fZBkKEKGnoD5N2vqOgeWrXl3vsGR8cWbo3lTxivVI\"\ndef get_neo4j_driver():\n    return GraphDatabase.driver(NEO4J_URI, auth=(USERNAME, PASSWORD))",
        "detail": "src.static_analysis.process_results.db_connection",
        "documentation": {}
    },
    {
        "label": "PASSWORD",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.db_connection",
        "description": "src.static_analysis.process_results.db_connection",
        "peekOfCode": "PASSWORD = \"C7fZBkKEKGnoD5N2vqOgeWrXl3vsGR8cWbo3lTxivVI\"\ndef get_neo4j_driver():\n    return GraphDatabase.driver(NEO4J_URI, auth=(USERNAME, PASSWORD))",
        "detail": "src.static_analysis.process_results.db_connection",
        "documentation": {}
    },
    {
        "label": "create_program",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "def create_program(tx, name, system, security):\n    \"\"\"Δημιουργία κόμβου Program με ασφαλή διαχείριση NULL τιμών\"\"\"\n    logger.info(f\"MERGE (p:Program [name: ${name}, system: ${system}, security: ${security}])\")\n    tx.run(\"\"\"\n        MERGE (p:Program {name: $name, system: $system, security: $security})\n    \"\"\", name=name, system=system, security=security if security is not None else \"\")\ndef create_flow(tx, program_name, name, input, output):\n    \"\"\"Δημιουργία κόμβου Flow και σύνδεση με το Program\"\"\"\n    logger.info(f\"\"\"\n        MERGE (f:Flow [name: ${name}, input: ${input}, output: ${output}])",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "create_flow",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "def create_flow(tx, program_name, name, input, output):\n    \"\"\"Δημιουργία κόμβου Flow και σύνδεση με το Program\"\"\"\n    logger.info(f\"\"\"\n        MERGE (f:Flow [name: ${name}, input: ${input}, output: ${output}])\n        WITH f\n        MATCH (p:Program [name: ${program_name}])\n        MERGE (p)-[:CONTAINS]->(f)\n                \"\"\")\n    tx.run(\"\"\"\n        MERGE (f:Flow {name: $name, input: $input, output: $output})",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "create_statement",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "def create_statement(tx, statement):\n    # logger.info(f\"statement={statement}\")\n    statement_type = statement[\"type\"]\n    # order = statement[\"order\"]\n    # Ανάλογα με το type, δημιουργούμε το σωστό node\n    if statement_type == \"StatementType.CONDITION\":\n        logger.info(f\"MERGE (s:ConditionalStatement [id: ${statement[\"id\"]}, methodName: ${statement.get(\"methodName\", \"\")}])\")\n        query = \"MERGE (s:ConditionalStatement {id: $id, methodName: $methodName})\"\n    elif statement_type == \"StatementType.CALL\":\n        logger.info(f\"MERGE (s:CallStatement [id: ${statement[\"id\"]}, methodName: ${statement.get(\"methodName\", \"\")}])\")",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "create_flow_to_statement_relationship",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "def create_flow_to_statement_relationship(tx, flow_name, first_statement_id):\n    logger.info(f\"\"\"\n        MATCH (f:Flow [name: ${flow_name}]), (s [id: ${first_statement_id}])\n        MERGE (f)-[:EXECUTES]->(s)\n    \"\"\")\n    tx.run(\"\"\"\n        MATCH (f:Flow {name: $flow_name}), (s {id: $first_statement_id})\n        MERGE (f)-[:EXECUTES]->(s)\n    \"\"\", flow_name=flow_name, first_statement_id=first_statement_id)\n# Δημιουργία Relationships (EXECUTES, TRUE_PATH, FALSE_PATH, NEXT)",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "create_relationship",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "def create_relationship(tx, source_id, target_id, relationship_type):\n    logger.info(f\"\"\"\n        MATCH (a [id: ${source_id}]), (b [id: ${target_id}])\n        MERGE (a)-[r:{relationship_type}]->(b)\n    \"\"\")\n    tx.run(\"\"\"\n        MATCH (a {id: $source_id}), (b {id: $target_id})\n        MERGE (a)-[r:%s]->(b)\n    \"\"\" % relationship_type, source_id=source_id, target_id=target_id)\n# ==================== Queries ",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "fetch_program_flow",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "def fetch_program_flow(self, flow_name):\n    query = \"\"\"\n    MATCH p=(program:Program )-[:CONTAINS]->(f:Flow {name: $flow_name})-[:EXECUTES|TRUE_PATH|FALSE_PATH|NEXT*]->(s)\n    RETURN p\n    \"\"\"\n    with self.driver.session() as session:\n        result = session.run(query, flow_name=flow_name)\n        return [record[\"p\"] for record in result]",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.db_context",
        "description": "src.static_analysis.process_results.db_context",
        "peekOfCode": "logger = logger.setup_logger('StaticAnalysisLogger', 'graph.log')\ndef create_program(tx, name, system, security):\n    \"\"\"Δημιουργία κόμβου Program με ασφαλή διαχείριση NULL τιμών\"\"\"\n    logger.info(f\"MERGE (p:Program [name: ${name}, system: ${system}, security: ${security}])\")\n    tx.run(\"\"\"\n        MERGE (p:Program {name: $name, system: $system, security: $security})\n    \"\"\", name=name, system=system, security=security if security is not None else \"\")\ndef create_flow(tx, program_name, name, input, output):\n    \"\"\"Δημιουργία κόμβου Flow και σύνδεση με το Program\"\"\"\n    logger.info(f\"\"\"",
        "detail": "src.static_analysis.process_results.db_context",
        "documentation": {}
    },
    {
        "label": "StatementPosition",
        "kind": 6,
        "importPath": "src.static_analysis.process_results.process",
        "description": "src.static_analysis.process_results.process",
        "peekOfCode": "class StatementPosition(Enum):\n    FIRST = \"first\"\n    MIDDLE = \"middle\"\n    LAST = \"last\"\ndef process_json_data(json_file):\n    \"\"\"\n    Parses a JSON file containing program flow information and inserts it into the Neo4j database.\n    Parameters:\n        json_file (str): Path to the JSON file containing static analysis data.\n    \"\"\"    ",
        "detail": "src.static_analysis.process_results.process",
        "documentation": {}
    },
    {
        "label": "process_json_data",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.process",
        "description": "src.static_analysis.process_results.process",
        "peekOfCode": "def process_json_data(json_file):\n    \"\"\"\n    Parses a JSON file containing program flow information and inserts it into the Neo4j database.\n    Parameters:\n        json_file (str): Path to the JSON file containing static analysis data.\n    \"\"\"    \n    print(BASE_DIR)\n    print(\"Current Working Directory:\", os.getcwd())\n    with open(json_file) as f:\n        data = json.load(f)",
        "detail": "src.static_analysis.process_results.process",
        "documentation": {}
    },
    {
        "label": "process_paragraph",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.process",
        "description": "src.static_analysis.process_results.process",
        "peekOfCode": "def process_paragraph(session, paragraph, flow_statements, flow_idx, next_statement_id, true_path=True):\n    \"\"\"\n    Processes conditional statements within a flow and ensures that their **true** and **false paths** are correctly recorded in the database.\n    Parameters:\n        session: Neo4j session instance.\n        paragraph (list): The block of statements inside a conditional branch.\n        flow_statements (list): The main list of statements in the flow.\n        flow_idx (int): The index of the current statement in the flow.\n        next_statement_id (str): The ID of the statement to execute next.\n        true_path (bool): Indicates whether this is the `TRUE_PATH` or `FALSE_PATH`.",
        "detail": "src.static_analysis.process_results.process",
        "documentation": {}
    },
    {
        "label": "is_condition",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.process",
        "description": "src.static_analysis.process_results.process",
        "peekOfCode": "def is_condition(statement):\n    return statement[\"type\"] == \"StatementType.CONDITION\"\ndef generate_relationship(source_id, target_id, relation):\n    return {\"source_id\": source_id, \"target_id\": target_id, \"relation\": relation}\nif __name__ == \"__main__\":\n    json_path = os.path.join(os.path.dirname(__file__),  \"DOGEMAIN.json\")\n    print(json_path)\n    with open(json_path) as f:\n        data = json.load(f)\n    process_json_data(json_path)",
        "detail": "src.static_analysis.process_results.process",
        "documentation": {}
    },
    {
        "label": "generate_relationship",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.process",
        "description": "src.static_analysis.process_results.process",
        "peekOfCode": "def generate_relationship(source_id, target_id, relation):\n    return {\"source_id\": source_id, \"target_id\": target_id, \"relation\": relation}\nif __name__ == \"__main__\":\n    json_path = os.path.join(os.path.dirname(__file__),  \"DOGEMAIN.json\")\n    print(json_path)\n    with open(json_path) as f:\n        data = json.load(f)\n    process_json_data(json_path)",
        "detail": "src.static_analysis.process_results.process",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.process",
        "description": "src.static_analysis.process_results.process",
        "peekOfCode": "BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../..\"))\nsys.path.append(BASE_DIR)\nimport json\nfrom static_analysis.process_results import db_connection, db_context\nfrom static_analysis import logger\nfrom static_analysis.process_results import db_connection, db_context\nfrom static_analysis import logger\nimport os\nfrom enum import Enum\nclass StatementPosition(Enum):",
        "detail": "src.static_analysis.process_results.process",
        "documentation": {}
    },
    {
        "label": "fetch_program_flow",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "def fetch_program_flow(flow_name):\n    query = \"\"\"\n    MATCH p=(program:Program)-[:CONTAINS]->(f:Flow {name: $flow_name})-[:EXECUTES|TRUE_PATH|FALSE_PATH|NEXT*]->(s)\n    RETURN \n    \"\"\"\n    with driver.session() as session:\n        result = session.run(query, flow_name=flow_name)\n        return [record[\"p\"] for record in result]\ndef get_execution_sequence_json(session, flow_name):\n    query = \"\"\"",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "get_execution_sequence_json",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "def get_execution_sequence_json(session, flow_name):\n    query = \"\"\"\n    MATCH (p:Program)-[:CONTAINS]->(f:Flow {name: $flow_name})\n    MATCH (f)-[:EXECUTES|NEXT|TRUE_PATH|FALSE_PATH*]->(s)\n    WITH p, f, s\n    OPTIONAL MATCH (s)-[r:EXECUTES|NEXT]->(next)\n    WITH p, f, s, COLLECT({relationship_type: type(r), next_statement_id: next.id}) AS executed\n    OPTIONAL MATCH (s)-[true_r:TRUE_PATH]->(true_next)\n    WITH p, f, s, executed, COLLECT({relationship_type: type(true_r), next_statement_id: true_next.id}) AS true_path\n    OPTIONAL MATCH (s)-[false_r:FALSE_PATH]->(false_next)",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "generate_diagrams",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "def generate_diagrams(flow_data, output_file=\"flow_diagram.puml\"):\n    plantuml_content = \"@startuml\\n\"\n    nodes = set()\n    relationships = set()\n    for path in flow_data:\n        for rel in path.relationships:\n            start_node = rel.start_node\n            end_node = rel.end_node\n            rel_type = rel.type\n            print(start_node.labels)",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "generate_plantuml_swimlane",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "def generate_plantuml_swimlane(paths, output_file=\"flow_diagram.puml\"):\n    \"\"\"Generates a PlantUML swimlane diagram from a list of paths.\"\"\"\n    swimlanes = {}  # Store nodes by their program name\n    relationships = []  # Store relationships between nodes\n    for path in paths:\n        nodes = path.nodes\n        for i in range(len(nodes)):\n            node = nodes[i]\n            if \"Program\" in node.labels:\n                program_name = node[\"name\"]",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../..\"))\nsys.path.append(BASE_DIR)\nimport json\nfrom static_analysis.process_results import db_connection\nfrom static_analysis import logger\nimport os\nfrom neo4j import exceptions\ndriver = db_connection.get_neo4j_driver()\ndef fetch_program_flow(flow_name):\n    query = \"\"\"",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "driver",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "driver = db_connection.get_neo4j_driver()\ndef fetch_program_flow(flow_name):\n    query = \"\"\"\n    MATCH p=(program:Program)-[:CONTAINS]->(f:Flow {name: $flow_name})-[:EXECUTES|TRUE_PATH|FALSE_PATH|NEXT*]->(s)\n    RETURN \n    \"\"\"\n    with driver.session() as session:\n        result = session.run(query, flow_name=flow_name)\n        return [record[\"p\"] for record in result]\ndef get_execution_sequence_json(session, flow_name):",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "flow_data",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.queries",
        "description": "src.static_analysis.process_results.queries",
        "peekOfCode": "flow_data = get_execution_sequence_json(driver.session(), \"00000-MAIN\")\ngenerate_diagrams(flow_data)\n# generate_plantuml_swimlane(flow_data)\ndriver.close()\nfor data in flow_data:\n    print(data)",
        "detail": "src.static_analysis.process_results.queries",
        "documentation": {}
    },
    {
        "label": "process_json_data",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.analyze_program",
        "description": "src.static_analysis.process_results.analyze_program",
        "peekOfCode": "def process_json_data(json_file):\n    with open(json_file) as f:\n        data = json.load(f)\n    return data\ndef evaluate(json_data, entry_point):\n    struct = []\n    flow = get_flow(json_data, entry_point)\n    for statement in flow['Statements']:\n        rate=0\n        match statement['type']:",
        "detail": "src.static_analysis.process_results.analyze_program",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.analyze_program",
        "description": "src.static_analysis.process_results.analyze_program",
        "peekOfCode": "def evaluate(json_data, entry_point):\n    struct = []\n    flow = get_flow(json_data, entry_point)\n    for statement in flow['Statements']:\n        rate=0\n        match statement['type']:\n            case 'StatementType.CONDITION': rate = 30\n            case 'StatementType.CALL': rate = 50\n            case 'StatementType.ASSIGN': rate = 10\n            case 'StatementType.OTHER': rate = 5",
        "detail": "src.static_analysis.process_results.analyze_program",
        "documentation": {}
    },
    {
        "label": "get_flow",
        "kind": 2,
        "importPath": "src.static_analysis.process_results.analyze_program",
        "description": "src.static_analysis.process_results.analyze_program",
        "peekOfCode": "def get_flow(data, flow_name):\n    main_node = next((node for node in data.get(\"Flows\", []) if node.get(\"Name\") == flow_name), None)\n    if main_node:\n        return main_node\n        # print(json.dumps(main_node, indent=4))\n    else:\n        print(\"Node '00000-MAIN' not found.\")\n    return None\nif __name__ == \"__main__\":\n    json_path = os.path.join(os.path.dirname(__file__),  \"..\\\\process_results\\\\DOGEMAIN.json\")",
        "detail": "src.static_analysis.process_results.analyze_program",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.static_analysis.process_results.analyze_program",
        "description": "src.static_analysis.process_results.analyze_program",
        "peekOfCode": "BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../..\"))\ndef process_json_data(json_file):\n    with open(json_file) as f:\n        data = json.load(f)\n    return data\ndef evaluate(json_data, entry_point):\n    struct = []\n    flow = get_flow(json_data, entry_point)\n    for statement in flow['Statements']:\n        rate=0",
        "detail": "src.static_analysis.process_results.analyze_program",
        "documentation": {}
    },
    {
        "label": "process_json_data",
        "kind": 2,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "def process_json_data(json_file, entry_point):\n    plantuml = []\n    print(BASE_DIR)\n    print(\"Current Working Directory:\", os.getcwd())\n    with open(json_file) as f:\n        data = json.load(f)\n    program_name = data[\"Program\"]\n    plantuml.append(f\"title {program_name}\")\n    plantuml.append(\"!theme materia\")\n    system = \"\" #data[\"Program\"].get(\"system\", \"\")",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "process_statement",
        "kind": 2,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "def process_statement(data, statement, lane, expanded = True):\n    plantuml=[]\n    if is_condition(statement):\n        plantuml.append(f\"  if ({statement[\"methodName\"]}) then (true)\")\n        for st in statement[\"TrueStatements\"]:\n                plantuml.append(f\"|{lane}|\")            \n                plantuml.extend(process_statement(data, st, lane))\n        if statement[\"FalseStatements\"]:\n            plantuml.append(\"else (false)\")\n            for st in statement[\"FalseStatements\"]:",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "get_flow",
        "kind": 2,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "def get_flow(data, flow_name):\n    main_node = next((node for node in data.get(\"Flows\", []) if node.get(\"Name\") == flow_name), None)\n    if main_node:\n        return main_node\n        # print(json.dumps(main_node, indent=4))\n    else:\n        print(\"Node '00000-MAIN' not found.\")\n    return None\ndef is_condition(statement):\n    return statement[\"type\"] == \"StatementType.CONDITION\"",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "is_condition",
        "kind": 2,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "def is_condition(statement):\n    return statement[\"type\"] == \"StatementType.CONDITION\"\ndef is_internal_call(statement):\n    return statement[\"type\"] == \"StatementType.CALL\"    \ndef is_external_call(statement):\n    return statement[\"type\"] == \"StatementType.CICS\"    \nif __name__ == \"__main__\":\n    json_path = os.path.join(os.path.dirname(__file__),  \"..\\\\process_results\\\\DOGEMAIN.json\")\n    # print(json_path)\n    # with open(json_path) as f:",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "is_internal_call",
        "kind": 2,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "def is_internal_call(statement):\n    return statement[\"type\"] == \"StatementType.CALL\"    \ndef is_external_call(statement):\n    return statement[\"type\"] == \"StatementType.CICS\"    \nif __name__ == \"__main__\":\n    json_path = os.path.join(os.path.dirname(__file__),  \"..\\\\process_results\\\\DOGEMAIN.json\")\n    # print(json_path)\n    # with open(json_path) as f:\n    #     data = json.load(f)\n    process_json_data(json_path, '00000-MAIN')      ",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "is_external_call",
        "kind": 2,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "def is_external_call(statement):\n    return statement[\"type\"] == \"StatementType.CICS\"    \nif __name__ == \"__main__\":\n    json_path = os.path.join(os.path.dirname(__file__),  \"..\\\\process_results\\\\DOGEMAIN.json\")\n    # print(json_path)\n    # with open(json_path) as f:\n    #     data = json.load(f)\n    process_json_data(json_path, '00000-MAIN')      \n    print(\"Analysis Completed!\")",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.static_analysis.diagrams.swimlane",
        "description": "src.static_analysis.diagrams.swimlane",
        "peekOfCode": "BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../..\"))\ndef process_json_data(json_file, entry_point):\n    plantuml = []\n    print(BASE_DIR)\n    print(\"Current Working Directory:\", os.getcwd())\n    with open(json_file) as f:\n        data = json.load(f)\n    program_name = data[\"Program\"]\n    plantuml.append(f\"title {program_name}\")\n    plantuml.append(\"!theme materia\")",
        "detail": "src.static_analysis.diagrams.swimlane",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "src.static_analysis.logger_builder",
        "description": "src.static_analysis.logger_builder",
        "peekOfCode": "def setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup a logger\"\"\"\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    console_handler = logging.StreamHandler()\n    handler = logging.FileHandler(log_file)        \n    console_handler.setFormatter(formatter)\n    handler.setFormatter(formatter)\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    logger.addHandler(handler)",
        "detail": "src.static_analysis.logger_builder",
        "documentation": {}
    }
]